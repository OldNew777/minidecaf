# Generated from MiniDecafExpr.g4 by ANTLR 4.8
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3-")
        buf.write("\u018c\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\3\2\6\2D\n\2\r\2\16\2E\3\2\3\2")
        buf.write("\3\3\3\3\3\3\3\3\5\3N\n\3\3\4\3\4\3\4\3\4\3\4\3\4\3\4")
        buf.write("\3\4\3\4\3\4\3\4\3\4\3\4\3\4\5\4^\n\4\3\5\3\5\3\5\3\5")
        buf.write("\3\5\7\5e\n\5\f\5\16\5h\13\5\3\6\3\6\3\6\7\6m\n\6\f\6")
        buf.write("\16\6p\13\6\5\6r\n\6\3\7\3\7\3\7\3\7\3\7\7\7y\n\7\f\7")
        buf.write("\16\7|\13\7\3\7\3\7\5\7\u0080\n\7\3\b\3\b\7\b\u0084\n")
        buf.write("\b\f\b\16\b\u0087\13\b\3\b\3\b\3\t\3\t\3\t\3\t\5\t\u008f")
        buf.write("\n\t\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3")
        buf.write("\n\3\n\3\n\5\n\u00a0\n\n\3\n\3\n\3\n\3\n\3\n\3\n\5\n\u00a8")
        buf.write("\n\n\3\n\3\n\5\n\u00ac\n\n\3\n\3\n\3\n\3\n\3\n\3\n\5\n")
        buf.write("\u00b4\n\n\3\n\3\n\5\n\u00b8\n\n\3\n\3\n\5\n\u00bc\n\n")
        buf.write("\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3")
        buf.write("\n\3\n\3\n\3\n\3\n\3\n\3\n\5\n\u00d2\n\n\3\13\3\13\3\f")
        buf.write("\3\f\3\f\3\f\3\f\5\f\u00db\n\f\3\r\3\r\3\r\3\r\3\r\3\r")
        buf.write("\3\r\5\r\u00e4\n\r\3\16\3\16\3\16\3\16\3\16\3\16\7\16")
        buf.write("\u00ec\n\16\f\16\16\16\u00ef\13\16\3\17\3\17\3\17\3\17")
        buf.write("\3\17\3\17\7\17\u00f7\n\17\f\17\16\17\u00fa\13\17\3\20")
        buf.write("\3\20\3\20\3\20\3\20\3\20\7\20\u0102\n\20\f\20\16\20\u0105")
        buf.write("\13\20\3\21\3\21\3\21\3\21\3\21\3\21\7\21\u010d\n\21\f")
        buf.write("\21\16\21\u0110\13\21\3\22\3\22\3\22\3\22\3\22\3\22\7")
        buf.write("\22\u0118\n\22\f\22\16\22\u011b\13\22\3\23\3\23\3\23\3")
        buf.write("\23\3\23\3\23\3\23\7\23\u0124\n\23\f\23\16\23\u0127\13")
        buf.write("\23\3\24\3\24\3\24\3\24\3\24\3\24\3\24\7\24\u0130\n\24")
        buf.write("\f\24\16\24\u0133\13\24\3\25\3\25\3\25\3\25\3\25\3\25")
        buf.write("\3\25\7\25\u013c\n\25\f\25\16\25\u013f\13\25\3\26\3\26")
        buf.write("\3\26\3\26\3\26\3\26\3\26\7\26\u0148\n\26\f\26\16\26\u014b")
        buf.write("\13\26\3\27\3\27\3\27\3\27\3\27\3\27\5\27\u0153\n\27\3")
        buf.write("\30\3\30\3\30\3\30\5\30\u0159\n\30\3\31\3\31\3\31\3\31")
        buf.write("\3\31\3\31\3\31\5\31\u0162\n\31\3\31\3\31\3\31\3\31\3")
        buf.write("\31\7\31\u0169\n\31\f\31\16\31\u016c\13\31\3\32\3\32\3")
        buf.write("\32\7\32\u0171\n\32\f\32\16\32\u0174\13\32\5\32\u0176")
        buf.write("\n\32\3\33\3\33\3\33\3\33\3\33\3\33\5\33\u017e\n\33\3")
        buf.write("\34\3\34\3\35\3\35\3\36\3\36\3\37\3\37\3 \3 \3!\3!\3!")
        buf.write("\2\r\b\32\34\36 \"$&(*\60\"\2\4\6\b\n\f\16\20\22\24\26")
        buf.write("\30\32\34\36 \"$&(*,.\60\62\64\668:<>@\2\7\3\2\31\32\3")
        buf.write("\2\33\35\3\2%&\4\2\32\33\36 \3\2!$\2\u0198\2C\3\2\2\2")
        buf.write("\4M\3\2\2\2\6]\3\2\2\2\b_\3\2\2\2\nq\3\2\2\2\fs\3\2\2")
        buf.write("\2\16\u0081\3\2\2\2\20\u008e\3\2\2\2\22\u00d1\3\2\2\2")
        buf.write("\24\u00d3\3\2\2\2\26\u00da\3\2\2\2\30\u00e3\3\2\2\2\32")
        buf.write("\u00e5\3\2\2\2\34\u00f0\3\2\2\2\36\u00fb\3\2\2\2 \u0106")
        buf.write("\3\2\2\2\"\u0111\3\2\2\2$\u011c\3\2\2\2&\u0128\3\2\2\2")
        buf.write("(\u0134\3\2\2\2*\u0140\3\2\2\2,\u0152\3\2\2\2.\u0158\3")
        buf.write("\2\2\2\60\u0161\3\2\2\2\62\u0175\3\2\2\2\64\u017d\3\2")
        buf.write("\2\2\66\u017f\3\2\2\28\u0181\3\2\2\2:\u0183\3\2\2\2<\u0185")
        buf.write("\3\2\2\2>\u0187\3\2\2\2@\u0189\3\2\2\2BD\5\4\3\2CB\3\2")
        buf.write("\2\2DE\3\2\2\2EC\3\2\2\2EF\3\2\2\2FG\3\2\2\2GH\7\2\2\3")
        buf.write("H\3\3\2\2\2IN\5\6\4\2JK\5\f\7\2KL\7\27\2\2LN\3\2\2\2M")
        buf.write("I\3\2\2\2MJ\3\2\2\2N\5\3\2\2\2OP\5\b\5\2PQ\7-\2\2QR\7")
        buf.write("\20\2\2RS\5\n\6\2ST\7\21\2\2TU\5\16\b\2U^\3\2\2\2VW\5")
        buf.write("\b\5\2WX\7-\2\2XY\7\20\2\2YZ\5\n\6\2Z[\7\21\2\2[\\\7\27")
        buf.write("\2\2\\^\3\2\2\2]O\3\2\2\2]V\3\2\2\2^\7\3\2\2\2_`\b\5\1")
        buf.write("\2`a\7\7\2\2af\3\2\2\2bc\f\3\2\2ce\7\33\2\2db\3\2\2\2")
        buf.write("eh\3\2\2\2fd\3\2\2\2fg\3\2\2\2g\t\3\2\2\2hf\3\2\2\2in")
        buf.write("\5\f\7\2jk\7\26\2\2km\5\f\7\2lj\3\2\2\2mp\3\2\2\2nl\3")
        buf.write("\2\2\2no\3\2\2\2or\3\2\2\2pn\3\2\2\2qi\3\2\2\2qr\3\2\2")
        buf.write("\2r\13\3\2\2\2st\5\b\5\2tz\7-\2\2uv\7\22\2\2vw\7+\2\2")
        buf.write("wy\7\23\2\2xu\3\2\2\2y|\3\2\2\2zx\3\2\2\2z{\3\2\2\2{\177")
        buf.write("\3\2\2\2|z\3\2\2\2}~\7\'\2\2~\u0080\5\24\13\2\177}\3\2")
        buf.write("\2\2\177\u0080\3\2\2\2\u0080\r\3\2\2\2\u0081\u0085\7\24")
        buf.write("\2\2\u0082\u0084\5\20\t\2\u0083\u0082\3\2\2\2\u0084\u0087")
        buf.write("\3\2\2\2\u0085\u0083\3\2\2\2\u0085\u0086\3\2\2\2\u0086")
        buf.write("\u0088\3\2\2\2\u0087\u0085\3\2\2\2\u0088\u0089\7\25\2")
        buf.write("\2\u0089\17\3\2\2\2\u008a\u008f\5\22\n\2\u008b\u008c\5")
        buf.write("\f\7\2\u008c\u008d\7\27\2\2\u008d\u008f\3\2\2\2\u008e")
        buf.write("\u008a\3\2\2\2\u008e\u008b\3\2\2\2\u008f\21\3\2\2\2\u0090")
        buf.write("\u0091\7\b\2\2\u0091\u0092\5\24\13\2\u0092\u0093\7\27")
        buf.write("\2\2\u0093\u00d2\3\2\2\2\u0094\u0095\5\24\13\2\u0095\u0096")
        buf.write("\7\27\2\2\u0096\u00d2\3\2\2\2\u0097\u00d2\7\27\2\2\u0098")
        buf.write("\u0099\7\t\2\2\u0099\u009a\7\20\2\2\u009a\u009b\5\24\13")
        buf.write("\2\u009b\u009c\7\21\2\2\u009c\u009f\5\22\n\2\u009d\u009e")
        buf.write("\7\n\2\2\u009e\u00a0\5\22\n\2\u009f\u009d\3\2\2\2\u009f")
        buf.write("\u00a0\3\2\2\2\u00a0\u00d2\3\2\2\2\u00a1\u00d2\5\16\b")
        buf.write("\2\u00a2\u00a3\7\13\2\2\u00a3\u00a4\7\20\2\2\u00a4\u00a5")
        buf.write("\5\f\7\2\u00a5\u00a7\7\27\2\2\u00a6\u00a8\5\24\13\2\u00a7")
        buf.write("\u00a6\3\2\2\2\u00a7\u00a8\3\2\2\2\u00a8\u00a9\3\2\2\2")
        buf.write("\u00a9\u00ab\7\27\2\2\u00aa\u00ac\5\24\13\2\u00ab\u00aa")
        buf.write("\3\2\2\2\u00ab\u00ac\3\2\2\2\u00ac\u00ad\3\2\2\2\u00ad")
        buf.write("\u00ae\7\21\2\2\u00ae\u00af\5\22\n\2\u00af\u00d2\3\2\2")
        buf.write("\2\u00b0\u00b1\7\13\2\2\u00b1\u00b3\7\20\2\2\u00b2\u00b4")
        buf.write("\5\24\13\2\u00b3\u00b2\3\2\2\2\u00b3\u00b4\3\2\2\2\u00b4")
        buf.write("\u00b5\3\2\2\2\u00b5\u00b7\7\27\2\2\u00b6\u00b8\5\24\13")
        buf.write("\2\u00b7\u00b6\3\2\2\2\u00b7\u00b8\3\2\2\2\u00b8\u00b9")
        buf.write("\3\2\2\2\u00b9\u00bb\7\27\2\2\u00ba\u00bc\5\24\13\2\u00bb")
        buf.write("\u00ba\3\2\2\2\u00bb\u00bc\3\2\2\2\u00bc\u00bd\3\2\2\2")
        buf.write("\u00bd\u00be\7\21\2\2\u00be\u00d2\5\22\n\2\u00bf\u00c0")
        buf.write("\7\r\2\2\u00c0\u00c1\7\20\2\2\u00c1\u00c2\5\24\13\2\u00c2")
        buf.write("\u00c3\7\21\2\2\u00c3\u00c4\5\22\n\2\u00c4\u00d2\3\2\2")
        buf.write("\2\u00c5\u00c6\7\f\2\2\u00c6\u00c7\5\22\n\2\u00c7\u00c8")
        buf.write("\7\r\2\2\u00c8\u00c9\7\20\2\2\u00c9\u00ca\5\24\13\2\u00ca")
        buf.write("\u00cb\7\21\2\2\u00cb\u00cc\7\27\2\2\u00cc\u00d2\3\2\2")
        buf.write("\2\u00cd\u00ce\7\16\2\2\u00ce\u00d2\7\27\2\2\u00cf\u00d0")
        buf.write("\7\17\2\2\u00d0\u00d2\7\27\2\2\u00d1\u0090\3\2\2\2\u00d1")
        buf.write("\u0094\3\2\2\2\u00d1\u0097\3\2\2\2\u00d1\u0098\3\2\2\2")
        buf.write("\u00d1\u00a1\3\2\2\2\u00d1\u00a2\3\2\2\2\u00d1\u00b0\3")
        buf.write("\2\2\2\u00d1\u00bf\3\2\2\2\u00d1\u00c5\3\2\2\2\u00d1\u00cd")
        buf.write("\3\2\2\2\u00d1\u00cf\3\2\2\2\u00d2\23\3\2\2\2\u00d3\u00d4")
        buf.write("\5\26\f\2\u00d4\25\3\2\2\2\u00d5\u00db\5\30\r\2\u00d6")
        buf.write("\u00d7\5.\30\2\u00d7\u00d8\5@!\2\u00d8\u00d9\5\26\f\2")
        buf.write("\u00d9\u00db\3\2\2\2\u00da\u00d5\3\2\2\2\u00da\u00d6\3")
        buf.write("\2\2\2\u00db\27\3\2\2\2\u00dc\u00e4\5\32\16\2\u00dd\u00de")
        buf.write("\5\32\16\2\u00de\u00df\7\3\2\2\u00df\u00e0\5\24\13\2\u00e0")
        buf.write("\u00e1\7\4\2\2\u00e1\u00e2\5\30\r\2\u00e2\u00e4\3\2\2")
        buf.write("\2\u00e3\u00dc\3\2\2\2\u00e3\u00dd\3\2\2\2\u00e4\31\3")
        buf.write("\2\2\2\u00e5\u00e6\b\16\1\2\u00e6\u00e7\5\34\17\2\u00e7")
        buf.write("\u00ed\3\2\2\2\u00e8\u00e9\f\3\2\2\u00e9\u00ea\7)\2\2")
        buf.write("\u00ea\u00ec\5\34\17\2\u00eb\u00e8\3\2\2\2\u00ec\u00ef")
        buf.write("\3\2\2\2\u00ed\u00eb\3\2\2\2\u00ed\u00ee\3\2\2\2\u00ee")
        buf.write("\33\3\2\2\2\u00ef\u00ed\3\2\2\2\u00f0\u00f1\b\17\1\2\u00f1")
        buf.write("\u00f2\5\36\20\2\u00f2\u00f8\3\2\2\2\u00f3\u00f4\f\3\2")
        buf.write("\2\u00f4\u00f5\7(\2\2\u00f5\u00f7\5\36\20\2\u00f6\u00f3")
        buf.write("\3\2\2\2\u00f7\u00fa\3\2\2\2\u00f8\u00f6\3\2\2\2\u00f8")
        buf.write("\u00f9\3\2\2\2\u00f9\35\3\2\2\2\u00fa\u00f8\3\2\2\2\u00fb")
        buf.write("\u00fc\b\20\1\2\u00fc\u00fd\5 \21\2\u00fd\u0103\3\2\2")
        buf.write("\2\u00fe\u00ff\f\3\2\2\u00ff\u0100\7\5\2\2\u0100\u0102")
        buf.write("\5 \21\2\u0101\u00fe\3\2\2\2\u0102\u0105\3\2\2\2\u0103")
        buf.write("\u0101\3\2\2\2\u0103\u0104\3\2\2\2\u0104\37\3\2\2\2\u0105")
        buf.write("\u0103\3\2\2\2\u0106\u0107\b\21\1\2\u0107\u0108\5\"\22")
        buf.write("\2\u0108\u010e\3\2\2\2\u0109\u010a\f\3\2\2\u010a\u010b")
        buf.write("\7\6\2\2\u010b\u010d\5\"\22\2\u010c\u0109\3\2\2\2\u010d")
        buf.write("\u0110\3\2\2\2\u010e\u010c\3\2\2\2\u010e\u010f\3\2\2\2")
        buf.write("\u010f!\3\2\2\2\u0110\u010e\3\2\2\2\u0111\u0112\b\22\1")
        buf.write("\2\u0112\u0113\5$\23\2\u0113\u0119\3\2\2\2\u0114\u0115")
        buf.write("\f\3\2\2\u0115\u0116\7 \2\2\u0116\u0118\5$\23\2\u0117")
        buf.write("\u0114\3\2\2\2\u0118\u011b\3\2\2\2\u0119\u0117\3\2\2\2")
        buf.write("\u0119\u011a\3\2\2\2\u011a#\3\2\2\2\u011b\u0119\3\2\2")
        buf.write("\2\u011c\u011d\b\23\1\2\u011d\u011e\5&\24\2\u011e\u0125")
        buf.write("\3\2\2\2\u011f\u0120\f\3\2\2\u0120\u0121\5:\36\2\u0121")
        buf.write("\u0122\5&\24\2\u0122\u0124\3\2\2\2\u0123\u011f\3\2\2\2")
        buf.write("\u0124\u0127\3\2\2\2\u0125\u0123\3\2\2\2\u0125\u0126\3")
        buf.write("\2\2\2\u0126%\3\2\2\2\u0127\u0125\3\2\2\2\u0128\u0129")
        buf.write("\b\24\1\2\u0129\u012a\5(\25\2\u012a\u0131\3\2\2\2\u012b")
        buf.write("\u012c\f\3\2\2\u012c\u012d\5> \2\u012d\u012e\5(\25\2\u012e")
        buf.write("\u0130\3\2\2\2\u012f\u012b\3\2\2\2\u0130\u0133\3\2\2\2")
        buf.write("\u0131\u012f\3\2\2\2\u0131\u0132\3\2\2\2\u0132\'\3\2\2")
        buf.write("\2\u0133\u0131\3\2\2\2\u0134\u0135\b\25\1\2\u0135\u0136")
        buf.write("\5*\26\2\u0136\u013d\3\2\2\2\u0137\u0138\f\3\2\2\u0138")
        buf.write("\u0139\5\66\34\2\u0139\u013a\5*\26\2\u013a\u013c\3\2\2")
        buf.write("\2\u013b\u0137\3\2\2\2\u013c\u013f\3\2\2\2\u013d\u013b")
        buf.write("\3\2\2\2\u013d\u013e\3\2\2\2\u013e)\3\2\2\2\u013f\u013d")
        buf.write("\3\2\2\2\u0140\u0141\b\26\1\2\u0141\u0142\5,\27\2\u0142")
        buf.write("\u0149\3\2\2\2\u0143\u0144\f\3\2\2\u0144\u0145\58\35\2")
        buf.write("\u0145\u0146\5,\27\2\u0146\u0148\3\2\2\2\u0147\u0143\3")
        buf.write("\2\2\2\u0148\u014b\3\2\2\2\u0149\u0147\3\2\2\2\u0149\u014a")
        buf.write("\3\2\2\2\u014a+\3\2\2\2\u014b\u0149\3\2\2\2\u014c\u0153")
        buf.write("\5.\30\2\u014d\u014e\7\20\2\2\u014e\u014f\5\b\5\2\u014f")
        buf.write("\u0150\7\21\2\2\u0150\u0151\5,\27\2\u0151\u0153\3\2\2")
        buf.write("\2\u0152\u014c\3\2\2\2\u0152\u014d\3\2\2\2\u0153-\3\2")
        buf.write("\2\2\u0154\u0159\5\60\31\2\u0155\u0156\5<\37\2\u0156\u0157")
        buf.write("\5,\27\2\u0157\u0159\3\2\2\2\u0158\u0154\3\2\2\2\u0158")
        buf.write("\u0155\3\2\2\2\u0159/\3\2\2\2\u015a\u015b\b\31\1\2\u015b")
        buf.write("\u0162\5\64\33\2\u015c\u015d\7-\2\2\u015d\u015e\7\20\2")
        buf.write("\2\u015e\u015f\5\62\32\2\u015f\u0160\7\21\2\2\u0160\u0162")
        buf.write("\3\2\2\2\u0161\u015a\3\2\2\2\u0161\u015c\3\2\2\2\u0162")
        buf.write("\u016a\3\2\2\2\u0163\u0164\f\4\2\2\u0164\u0165\7\22\2")
        buf.write("\2\u0165\u0166\5\24\13\2\u0166\u0167\7\23\2\2\u0167\u0169")
        buf.write("\3\2\2\2\u0168\u0163\3\2\2\2\u0169\u016c\3\2\2\2\u016a")
        buf.write("\u0168\3\2\2\2\u016a\u016b\3\2\2\2\u016b\61\3\2\2\2\u016c")
        buf.write("\u016a\3\2\2\2\u016d\u0172\5\24\13\2\u016e\u016f\7\26")
        buf.write("\2\2\u016f\u0171\5\24\13\2\u0170\u016e\3\2\2\2\u0171\u0174")
        buf.write("\3\2\2\2\u0172\u0170\3\2\2\2\u0172\u0173\3\2\2\2\u0173")
        buf.write("\u0176\3\2\2\2\u0174\u0172\3\2\2\2\u0175\u016d\3\2\2\2")
        buf.write("\u0175\u0176\3\2\2\2\u0176\63\3\2\2\2\u0177\u017e\7+\2")
        buf.write("\2\u0178\u017e\7-\2\2\u0179\u017a\7\20\2\2\u017a\u017b")
        buf.write("\5\24\13\2\u017b\u017c\7\21\2\2\u017c\u017e\3\2\2\2\u017d")
        buf.write("\u0177\3\2\2\2\u017d\u0178\3\2\2\2\u017d\u0179\3\2\2\2")
        buf.write("\u017e\65\3\2\2\2\u017f\u0180\t\2\2\2\u0180\67\3\2\2\2")
        buf.write("\u0181\u0182\t\3\2\2\u01829\3\2\2\2\u0183\u0184\t\4\2")
        buf.write("\2\u0184;\3\2\2\2\u0185\u0186\t\5\2\2\u0186=\3\2\2\2\u0187")
        buf.write("\u0188\t\6\2\2\u0188?\3\2\2\2\u0189\u018a\7\'\2\2\u018a")
        buf.write("A\3\2\2\2%EM]fnqz\177\u0085\u008e\u009f\u00a7\u00ab\u00b3")
        buf.write("\u00b7\u00bb\u00d1\u00da\u00e3\u00ed\u00f8\u0103\u010e")
        buf.write("\u0119\u0125\u0131\u013d\u0149\u0152\u0158\u0161\u016a")
        buf.write("\u0172\u0175\u017d")
        return buf.getvalue()


class MiniDecafExprParser ( Parser ):

    grammarFileName = "MiniDecafExpr.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'?'", "':'", "'|'", "'^'", "'int'", "'return'", 
                     "'if'", "'else'", "'for'", "'do'", "'while'", "'break'", 
                     "'continue'", "'('", "')'", "'['", "']'", "'{'", "'}'", 
                     "','", "';'", "<INVALID>", "'+'", "'-'", "'*'", "'/'", 
                     "'%'", "'!'", "'~'", "'&'", "'<'", "'>'", "'<='", "'>='", 
                     "'=='", "'!='", "'='", "'&&'", "'||'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "Int", "Return", "If", "Else", "For", 
                      "Do", "While", "Break", "Continue", "Lparen", "Rparen", 
                      "Lbrkt", "Rbrkt", "Lbrace", "Rbrace", "Comma", "Semicolon", 
                      "Punctuator", "Add", "Sub", "Mul", "Div", "Percent", 
                      "Exclamation", "Tilde", "Ampersand", "Langle", "Rangle", 
                      "Langle_eq", "Rangle_eq", "Double_eq", "Exclam_eq", 
                      "Equal", "Double_amp", "Double_bar", "Operator", "Integer", 
                      "Whitespace", "Identifier" ]

    RULE_program = 0
    RULE_externalDecline = 1
    RULE_function = 2
    RULE_variableType = 3
    RULE_parameterList = 4
    RULE_declaration = 5
    RULE_block = 6
    RULE_blockItem = 7
    RULE_statement = 8
    RULE_expression = 9
    RULE_assign = 10
    RULE_conditional = 11
    RULE_logical_or = 12
    RULE_logical_and = 13
    RULE_bit_or = 14
    RULE_bit_xor = 15
    RULE_bit_and = 16
    RULE_equal = 17
    RULE_relational = 18
    RULE_add = 19
    RULE_multiply = 20
    RULE_cast = 21
    RULE_unary = 22
    RULE_postfix = 23
    RULE_argumentList = 24
    RULE_atom = 25
    RULE_addOperator = 26
    RULE_multiplyOperator = 27
    RULE_equalOperator = 28
    RULE_unaryOperator = 29
    RULE_relationalOperator = 30
    RULE_assignOperator = 31

    ruleNames =  [ "program", "externalDecline", "function", "variableType", 
                   "parameterList", "declaration", "block", "blockItem", 
                   "statement", "expression", "assign", "conditional", "logical_or", 
                   "logical_and", "bit_or", "bit_xor", "bit_and", "equal", 
                   "relational", "add", "multiply", "cast", "unary", "postfix", 
                   "argumentList", "atom", "addOperator", "multiplyOperator", 
                   "equalOperator", "unaryOperator", "relationalOperator", 
                   "assignOperator" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    Int=5
    Return=6
    If=7
    Else=8
    For=9
    Do=10
    While=11
    Break=12
    Continue=13
    Lparen=14
    Rparen=15
    Lbrkt=16
    Rbrkt=17
    Lbrace=18
    Rbrace=19
    Comma=20
    Semicolon=21
    Punctuator=22
    Add=23
    Sub=24
    Mul=25
    Div=26
    Percent=27
    Exclamation=28
    Tilde=29
    Ampersand=30
    Langle=31
    Rangle=32
    Langle_eq=33
    Rangle_eq=34
    Double_eq=35
    Exclam_eq=36
    Equal=37
    Double_amp=38
    Double_bar=39
    Operator=40
    Integer=41
    Whitespace=42
    Identifier=43

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(MiniDecafExprParser.EOF, 0)

        def externalDecline(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MiniDecafExprParser.ExternalDeclineContext)
            else:
                return self.getTypedRuleContext(MiniDecafExprParser.ExternalDeclineContext,i)


        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = MiniDecafExprParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 65 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 64
                self.externalDecline()
                self.state = 67 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==MiniDecafExprParser.Int):
                    break

            self.state = 69
            self.match(MiniDecafExprParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExternalDeclineContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_externalDecline

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class DeclarationExternalContext(ExternalDeclineContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.ExternalDeclineContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def declaration(self):
            return self.getTypedRuleContext(MiniDecafExprParser.DeclarationContext,0)

        def Semicolon(self):
            return self.getToken(MiniDecafExprParser.Semicolon, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclarationExternal" ):
                listener.enterDeclarationExternal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclarationExternal" ):
                listener.exitDeclarationExternal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeclarationExternal" ):
                return visitor.visitDeclarationExternal(self)
            else:
                return visitor.visitChildren(self)


    class FunctionExternalContext(ExternalDeclineContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.ExternalDeclineContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def function(self):
            return self.getTypedRuleContext(MiniDecafExprParser.FunctionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionExternal" ):
                listener.enterFunctionExternal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionExternal" ):
                listener.exitFunctionExternal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionExternal" ):
                return visitor.visitFunctionExternal(self)
            else:
                return visitor.visitChildren(self)



    def externalDecline(self):

        localctx = MiniDecafExprParser.ExternalDeclineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_externalDecline)
        try:
            self.state = 75
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                localctx = MiniDecafExprParser.FunctionExternalContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 71
                self.function()
                pass

            elif la_ == 2:
                localctx = MiniDecafExprParser.DeclarationExternalContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 72
                self.declaration()
                self.state = 73
                self.match(MiniDecafExprParser.Semicolon)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_function

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class FunctionDefineContext(FunctionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.FunctionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def variableType(self):
            return self.getTypedRuleContext(MiniDecafExprParser.VariableTypeContext,0)

        def Identifier(self):
            return self.getToken(MiniDecafExprParser.Identifier, 0)
        def Lparen(self):
            return self.getToken(MiniDecafExprParser.Lparen, 0)
        def parameterList(self):
            return self.getTypedRuleContext(MiniDecafExprParser.ParameterListContext,0)

        def Rparen(self):
            return self.getToken(MiniDecafExprParser.Rparen, 0)
        def block(self):
            return self.getTypedRuleContext(MiniDecafExprParser.BlockContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionDefine" ):
                listener.enterFunctionDefine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionDefine" ):
                listener.exitFunctionDefine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionDefine" ):
                return visitor.visitFunctionDefine(self)
            else:
                return visitor.visitChildren(self)


    class FunctionDeclarationContext(FunctionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.FunctionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def variableType(self):
            return self.getTypedRuleContext(MiniDecafExprParser.VariableTypeContext,0)

        def Identifier(self):
            return self.getToken(MiniDecafExprParser.Identifier, 0)
        def Lparen(self):
            return self.getToken(MiniDecafExprParser.Lparen, 0)
        def parameterList(self):
            return self.getTypedRuleContext(MiniDecafExprParser.ParameterListContext,0)

        def Rparen(self):
            return self.getToken(MiniDecafExprParser.Rparen, 0)
        def Semicolon(self):
            return self.getToken(MiniDecafExprParser.Semicolon, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionDeclaration" ):
                listener.enterFunctionDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionDeclaration" ):
                listener.exitFunctionDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionDeclaration" ):
                return visitor.visitFunctionDeclaration(self)
            else:
                return visitor.visitChildren(self)



    def function(self):

        localctx = MiniDecafExprParser.FunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_function)
        try:
            self.state = 91
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                localctx = MiniDecafExprParser.FunctionDefineContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 77
                self.variableType(0)
                self.state = 78
                self.match(MiniDecafExprParser.Identifier)
                self.state = 79
                self.match(MiniDecafExprParser.Lparen)
                self.state = 80
                self.parameterList()
                self.state = 81
                self.match(MiniDecafExprParser.Rparen)
                self.state = 82
                self.block()
                pass

            elif la_ == 2:
                localctx = MiniDecafExprParser.FunctionDeclarationContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 84
                self.variableType(0)
                self.state = 85
                self.match(MiniDecafExprParser.Identifier)
                self.state = 86
                self.match(MiniDecafExprParser.Lparen)
                self.state = 87
                self.parameterList()
                self.state = 88
                self.match(MiniDecafExprParser.Rparen)
                self.state = 89
                self.match(MiniDecafExprParser.Semicolon)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_variableType

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class PointerTypeContext(VariableTypeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.VariableTypeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def variableType(self):
            return self.getTypedRuleContext(MiniDecafExprParser.VariableTypeContext,0)

        def Mul(self):
            return self.getToken(MiniDecafExprParser.Mul, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPointerType" ):
                listener.enterPointerType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPointerType" ):
                listener.exitPointerType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPointerType" ):
                return visitor.visitPointerType(self)
            else:
                return visitor.visitChildren(self)


    class IntTypeContext(VariableTypeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.VariableTypeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Int(self):
            return self.getToken(MiniDecafExprParser.Int, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntType" ):
                listener.enterIntType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntType" ):
                listener.exitIntType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntType" ):
                return visitor.visitIntType(self)
            else:
                return visitor.visitChildren(self)



    def variableType(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = MiniDecafExprParser.VariableTypeContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 6
        self.enterRecursionRule(localctx, 6, self.RULE_variableType, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = MiniDecafExprParser.IntTypeContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 94
            self.match(MiniDecafExprParser.Int)
            self._ctx.stop = self._input.LT(-1)
            self.state = 100
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,3,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = MiniDecafExprParser.PointerTypeContext(self, MiniDecafExprParser.VariableTypeContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_variableType)
                    self.state = 96
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 97
                    self.match(MiniDecafExprParser.Mul) 
                self.state = 102
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,3,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ParameterListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MiniDecafExprParser.DeclarationContext)
            else:
                return self.getTypedRuleContext(MiniDecafExprParser.DeclarationContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(MiniDecafExprParser.Comma)
            else:
                return self.getToken(MiniDecafExprParser.Comma, i)

        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_parameterList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterList" ):
                listener.enterParameterList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterList" ):
                listener.exitParameterList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterList" ):
                return visitor.visitParameterList(self)
            else:
                return visitor.visitChildren(self)




    def parameterList(self):

        localctx = MiniDecafExprParser.ParameterListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_parameterList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 111
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==MiniDecafExprParser.Int:
                self.state = 103
                self.declaration()
                self.state = 108
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==MiniDecafExprParser.Comma:
                    self.state = 104
                    self.match(MiniDecafExprParser.Comma)
                    self.state = 105
                    self.declaration()
                    self.state = 110
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableType(self):
            return self.getTypedRuleContext(MiniDecafExprParser.VariableTypeContext,0)


        def Identifier(self):
            return self.getToken(MiniDecafExprParser.Identifier, 0)

        def Lbrkt(self, i:int=None):
            if i is None:
                return self.getTokens(MiniDecafExprParser.Lbrkt)
            else:
                return self.getToken(MiniDecafExprParser.Lbrkt, i)

        def Integer(self, i:int=None):
            if i is None:
                return self.getTokens(MiniDecafExprParser.Integer)
            else:
                return self.getToken(MiniDecafExprParser.Integer, i)

        def Rbrkt(self, i:int=None):
            if i is None:
                return self.getTokens(MiniDecafExprParser.Rbrkt)
            else:
                return self.getToken(MiniDecafExprParser.Rbrkt, i)

        def Equal(self):
            return self.getToken(MiniDecafExprParser.Equal, 0)

        def expression(self):
            return self.getTypedRuleContext(MiniDecafExprParser.ExpressionContext,0)


        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclaration" ):
                listener.enterDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclaration" ):
                listener.exitDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeclaration" ):
                return visitor.visitDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def declaration(self):

        localctx = MiniDecafExprParser.DeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 113
            self.variableType(0)
            self.state = 114
            self.match(MiniDecafExprParser.Identifier)
            self.state = 120
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==MiniDecafExprParser.Lbrkt:
                self.state = 115
                self.match(MiniDecafExprParser.Lbrkt)
                self.state = 116
                self.match(MiniDecafExprParser.Integer)
                self.state = 117
                self.match(MiniDecafExprParser.Rbrkt)
                self.state = 122
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 125
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==MiniDecafExprParser.Equal:
                self.state = 123
                self.match(MiniDecafExprParser.Equal)
                self.state = 124
                self.expression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Lbrace(self):
            return self.getToken(MiniDecafExprParser.Lbrace, 0)

        def Rbrace(self):
            return self.getToken(MiniDecafExprParser.Rbrace, 0)

        def blockItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MiniDecafExprParser.BlockItemContext)
            else:
                return self.getTypedRuleContext(MiniDecafExprParser.BlockItemContext,i)


        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlock" ):
                listener.enterBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlock" ):
                listener.exitBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlock" ):
                return visitor.visitBlock(self)
            else:
                return visitor.visitChildren(self)




    def block(self):

        localctx = MiniDecafExprParser.BlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_block)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 127
            self.match(MiniDecafExprParser.Lbrace)
            self.state = 131
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << MiniDecafExprParser.Int) | (1 << MiniDecafExprParser.Return) | (1 << MiniDecafExprParser.If) | (1 << MiniDecafExprParser.For) | (1 << MiniDecafExprParser.Do) | (1 << MiniDecafExprParser.While) | (1 << MiniDecafExprParser.Break) | (1 << MiniDecafExprParser.Continue) | (1 << MiniDecafExprParser.Lparen) | (1 << MiniDecafExprParser.Lbrace) | (1 << MiniDecafExprParser.Semicolon) | (1 << MiniDecafExprParser.Sub) | (1 << MiniDecafExprParser.Mul) | (1 << MiniDecafExprParser.Exclamation) | (1 << MiniDecafExprParser.Tilde) | (1 << MiniDecafExprParser.Ampersand) | (1 << MiniDecafExprParser.Integer) | (1 << MiniDecafExprParser.Identifier))) != 0):
                self.state = 128
                self.blockItem()
                self.state = 133
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 134
            self.match(MiniDecafExprParser.Rbrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlockItemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_blockItem

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class BlockItemStatementContext(BlockItemContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.BlockItemContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def statement(self):
            return self.getTypedRuleContext(MiniDecafExprParser.StatementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlockItemStatement" ):
                listener.enterBlockItemStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlockItemStatement" ):
                listener.exitBlockItemStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlockItemStatement" ):
                return visitor.visitBlockItemStatement(self)
            else:
                return visitor.visitChildren(self)


    class BlockItemDeclarationContext(BlockItemContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.BlockItemContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def declaration(self):
            return self.getTypedRuleContext(MiniDecafExprParser.DeclarationContext,0)

        def Semicolon(self):
            return self.getToken(MiniDecafExprParser.Semicolon, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlockItemDeclaration" ):
                listener.enterBlockItemDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlockItemDeclaration" ):
                listener.exitBlockItemDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlockItemDeclaration" ):
                return visitor.visitBlockItemDeclaration(self)
            else:
                return visitor.visitChildren(self)



    def blockItem(self):

        localctx = MiniDecafExprParser.BlockItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_blockItem)
        try:
            self.state = 140
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [MiniDecafExprParser.Return, MiniDecafExprParser.If, MiniDecafExprParser.For, MiniDecafExprParser.Do, MiniDecafExprParser.While, MiniDecafExprParser.Break, MiniDecafExprParser.Continue, MiniDecafExprParser.Lparen, MiniDecafExprParser.Lbrace, MiniDecafExprParser.Semicolon, MiniDecafExprParser.Sub, MiniDecafExprParser.Mul, MiniDecafExprParser.Exclamation, MiniDecafExprParser.Tilde, MiniDecafExprParser.Ampersand, MiniDecafExprParser.Integer, MiniDecafExprParser.Identifier]:
                localctx = MiniDecafExprParser.BlockItemStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 136
                self.statement()
                pass
            elif token in [MiniDecafExprParser.Int]:
                localctx = MiniDecafExprParser.BlockItemDeclarationContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 137
                self.declaration()
                self.state = 138
                self.match(MiniDecafExprParser.Semicolon)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_statement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class WhileStatementContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def While(self):
            return self.getToken(MiniDecafExprParser.While, 0)
        def Lparen(self):
            return self.getToken(MiniDecafExprParser.Lparen, 0)
        def expression(self):
            return self.getTypedRuleContext(MiniDecafExprParser.ExpressionContext,0)

        def Rparen(self):
            return self.getToken(MiniDecafExprParser.Rparen, 0)
        def statement(self):
            return self.getTypedRuleContext(MiniDecafExprParser.StatementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhileStatement" ):
                listener.enterWhileStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhileStatement" ):
                listener.exitWhileStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhileStatement" ):
                return visitor.visitWhileStatement(self)
            else:
                return visitor.visitChildren(self)


    class BlockStatementContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def block(self):
            return self.getTypedRuleContext(MiniDecafExprParser.BlockContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlockStatement" ):
                listener.enterBlockStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlockStatement" ):
                listener.exitBlockStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlockStatement" ):
                return visitor.visitBlockStatement(self)
            else:
                return visitor.visitChildren(self)


    class BlankStatementContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Semicolon(self):
            return self.getToken(MiniDecafExprParser.Semicolon, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlankStatement" ):
                listener.enterBlankStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlankStatement" ):
                listener.exitBlankStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlankStatement" ):
                return visitor.visitBlankStatement(self)
            else:
                return visitor.visitChildren(self)


    class ForDeclarationStatementContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.StatementContext
            super().__init__(parser)
            self.init = None # DeclarationContext
            self.ctrl = None # ExpressionContext
            self.post = None # ExpressionContext
            self.copyFrom(ctx)

        def For(self):
            return self.getToken(MiniDecafExprParser.For, 0)
        def Lparen(self):
            return self.getToken(MiniDecafExprParser.Lparen, 0)
        def Semicolon(self, i:int=None):
            if i is None:
                return self.getTokens(MiniDecafExprParser.Semicolon)
            else:
                return self.getToken(MiniDecafExprParser.Semicolon, i)
        def Rparen(self):
            return self.getToken(MiniDecafExprParser.Rparen, 0)
        def statement(self):
            return self.getTypedRuleContext(MiniDecafExprParser.StatementContext,0)

        def declaration(self):
            return self.getTypedRuleContext(MiniDecafExprParser.DeclarationContext,0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MiniDecafExprParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(MiniDecafExprParser.ExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForDeclarationStatement" ):
                listener.enterForDeclarationStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForDeclarationStatement" ):
                listener.exitForDeclarationStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForDeclarationStatement" ):
                return visitor.visitForDeclarationStatement(self)
            else:
                return visitor.visitChildren(self)


    class ForStatementContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.StatementContext
            super().__init__(parser)
            self.init = None # ExpressionContext
            self.ctrl = None # ExpressionContext
            self.post = None # ExpressionContext
            self.copyFrom(ctx)

        def For(self):
            return self.getToken(MiniDecafExprParser.For, 0)
        def Lparen(self):
            return self.getToken(MiniDecafExprParser.Lparen, 0)
        def Semicolon(self, i:int=None):
            if i is None:
                return self.getTokens(MiniDecafExprParser.Semicolon)
            else:
                return self.getToken(MiniDecafExprParser.Semicolon, i)
        def Rparen(self):
            return self.getToken(MiniDecafExprParser.Rparen, 0)
        def statement(self):
            return self.getTypedRuleContext(MiniDecafExprParser.StatementContext,0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MiniDecafExprParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(MiniDecafExprParser.ExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForStatement" ):
                listener.enterForStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForStatement" ):
                listener.exitForStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForStatement" ):
                return visitor.visitForStatement(self)
            else:
                return visitor.visitChildren(self)


    class BreakStatementContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Break(self):
            return self.getToken(MiniDecafExprParser.Break, 0)
        def Semicolon(self):
            return self.getToken(MiniDecafExprParser.Semicolon, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBreakStatement" ):
                listener.enterBreakStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBreakStatement" ):
                listener.exitBreakStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBreakStatement" ):
                return visitor.visitBreakStatement(self)
            else:
                return visitor.visitChildren(self)


    class ExpressionStatementContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(MiniDecafExprParser.ExpressionContext,0)

        def Semicolon(self):
            return self.getToken(MiniDecafExprParser.Semicolon, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionStatement" ):
                listener.enterExpressionStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionStatement" ):
                listener.exitExpressionStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressionStatement" ):
                return visitor.visitExpressionStatement(self)
            else:
                return visitor.visitChildren(self)


    class DoWhileStatementContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Do(self):
            return self.getToken(MiniDecafExprParser.Do, 0)
        def statement(self):
            return self.getTypedRuleContext(MiniDecafExprParser.StatementContext,0)

        def While(self):
            return self.getToken(MiniDecafExprParser.While, 0)
        def Lparen(self):
            return self.getToken(MiniDecafExprParser.Lparen, 0)
        def expression(self):
            return self.getTypedRuleContext(MiniDecafExprParser.ExpressionContext,0)

        def Rparen(self):
            return self.getToken(MiniDecafExprParser.Rparen, 0)
        def Semicolon(self):
            return self.getToken(MiniDecafExprParser.Semicolon, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDoWhileStatement" ):
                listener.enterDoWhileStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDoWhileStatement" ):
                listener.exitDoWhileStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDoWhileStatement" ):
                return visitor.visitDoWhileStatement(self)
            else:
                return visitor.visitChildren(self)


    class ContinueStatementContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Continue(self):
            return self.getToken(MiniDecafExprParser.Continue, 0)
        def Semicolon(self):
            return self.getToken(MiniDecafExprParser.Semicolon, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContinueStatement" ):
                listener.enterContinueStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContinueStatement" ):
                listener.exitContinueStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitContinueStatement" ):
                return visitor.visitContinueStatement(self)
            else:
                return visitor.visitChildren(self)


    class ReturnStatementContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Return(self):
            return self.getToken(MiniDecafExprParser.Return, 0)
        def expression(self):
            return self.getTypedRuleContext(MiniDecafExprParser.ExpressionContext,0)

        def Semicolon(self):
            return self.getToken(MiniDecafExprParser.Semicolon, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnStatement" ):
                listener.enterReturnStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnStatement" ):
                listener.exitReturnStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnStatement" ):
                return visitor.visitReturnStatement(self)
            else:
                return visitor.visitChildren(self)


    class IfStatementContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.StatementContext
            super().__init__(parser)
            self.thenStatement = None # StatementContext
            self.elseStatement = None # StatementContext
            self.copyFrom(ctx)

        def If(self):
            return self.getToken(MiniDecafExprParser.If, 0)
        def Lparen(self):
            return self.getToken(MiniDecafExprParser.Lparen, 0)
        def expression(self):
            return self.getTypedRuleContext(MiniDecafExprParser.ExpressionContext,0)

        def Rparen(self):
            return self.getToken(MiniDecafExprParser.Rparen, 0)
        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MiniDecafExprParser.StatementContext)
            else:
                return self.getTypedRuleContext(MiniDecafExprParser.StatementContext,i)

        def Else(self):
            return self.getToken(MiniDecafExprParser.Else, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfStatement" ):
                listener.enterIfStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfStatement" ):
                listener.exitIfStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfStatement" ):
                return visitor.visitIfStatement(self)
            else:
                return visitor.visitChildren(self)



    def statement(self):

        localctx = MiniDecafExprParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_statement)
        self._la = 0 # Token type
        try:
            self.state = 207
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                localctx = MiniDecafExprParser.ReturnStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 142
                self.match(MiniDecafExprParser.Return)
                self.state = 143
                self.expression()
                self.state = 144
                self.match(MiniDecafExprParser.Semicolon)
                pass

            elif la_ == 2:
                localctx = MiniDecafExprParser.ExpressionStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 146
                self.expression()
                self.state = 147
                self.match(MiniDecafExprParser.Semicolon)
                pass

            elif la_ == 3:
                localctx = MiniDecafExprParser.BlankStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 149
                self.match(MiniDecafExprParser.Semicolon)
                pass

            elif la_ == 4:
                localctx = MiniDecafExprParser.IfStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 150
                self.match(MiniDecafExprParser.If)
                self.state = 151
                self.match(MiniDecafExprParser.Lparen)
                self.state = 152
                self.expression()
                self.state = 153
                self.match(MiniDecafExprParser.Rparen)
                self.state = 154
                localctx.thenStatement = self.statement()
                self.state = 157
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
                if la_ == 1:
                    self.state = 155
                    self.match(MiniDecafExprParser.Else)
                    self.state = 156
                    localctx.elseStatement = self.statement()


                pass

            elif la_ == 5:
                localctx = MiniDecafExprParser.BlockStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 159
                self.block()
                pass

            elif la_ == 6:
                localctx = MiniDecafExprParser.ForDeclarationStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 160
                self.match(MiniDecafExprParser.For)
                self.state = 161
                self.match(MiniDecafExprParser.Lparen)
                self.state = 162
                localctx.init = self.declaration()
                self.state = 163
                self.match(MiniDecafExprParser.Semicolon)
                self.state = 165
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << MiniDecafExprParser.Lparen) | (1 << MiniDecafExprParser.Sub) | (1 << MiniDecafExprParser.Mul) | (1 << MiniDecafExprParser.Exclamation) | (1 << MiniDecafExprParser.Tilde) | (1 << MiniDecafExprParser.Ampersand) | (1 << MiniDecafExprParser.Integer) | (1 << MiniDecafExprParser.Identifier))) != 0):
                    self.state = 164
                    localctx.ctrl = self.expression()


                self.state = 167
                self.match(MiniDecafExprParser.Semicolon)
                self.state = 169
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << MiniDecafExprParser.Lparen) | (1 << MiniDecafExprParser.Sub) | (1 << MiniDecafExprParser.Mul) | (1 << MiniDecafExprParser.Exclamation) | (1 << MiniDecafExprParser.Tilde) | (1 << MiniDecafExprParser.Ampersand) | (1 << MiniDecafExprParser.Integer) | (1 << MiniDecafExprParser.Identifier))) != 0):
                    self.state = 168
                    localctx.post = self.expression()


                self.state = 171
                self.match(MiniDecafExprParser.Rparen)
                self.state = 172
                self.statement()
                pass

            elif la_ == 7:
                localctx = MiniDecafExprParser.ForStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 174
                self.match(MiniDecafExprParser.For)
                self.state = 175
                self.match(MiniDecafExprParser.Lparen)
                self.state = 177
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << MiniDecafExprParser.Lparen) | (1 << MiniDecafExprParser.Sub) | (1 << MiniDecafExprParser.Mul) | (1 << MiniDecafExprParser.Exclamation) | (1 << MiniDecafExprParser.Tilde) | (1 << MiniDecafExprParser.Ampersand) | (1 << MiniDecafExprParser.Integer) | (1 << MiniDecafExprParser.Identifier))) != 0):
                    self.state = 176
                    localctx.init = self.expression()


                self.state = 179
                self.match(MiniDecafExprParser.Semicolon)
                self.state = 181
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << MiniDecafExprParser.Lparen) | (1 << MiniDecafExprParser.Sub) | (1 << MiniDecafExprParser.Mul) | (1 << MiniDecafExprParser.Exclamation) | (1 << MiniDecafExprParser.Tilde) | (1 << MiniDecafExprParser.Ampersand) | (1 << MiniDecafExprParser.Integer) | (1 << MiniDecafExprParser.Identifier))) != 0):
                    self.state = 180
                    localctx.ctrl = self.expression()


                self.state = 183
                self.match(MiniDecafExprParser.Semicolon)
                self.state = 185
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << MiniDecafExprParser.Lparen) | (1 << MiniDecafExprParser.Sub) | (1 << MiniDecafExprParser.Mul) | (1 << MiniDecafExprParser.Exclamation) | (1 << MiniDecafExprParser.Tilde) | (1 << MiniDecafExprParser.Ampersand) | (1 << MiniDecafExprParser.Integer) | (1 << MiniDecafExprParser.Identifier))) != 0):
                    self.state = 184
                    localctx.post = self.expression()


                self.state = 187
                self.match(MiniDecafExprParser.Rparen)
                self.state = 188
                self.statement()
                pass

            elif la_ == 8:
                localctx = MiniDecafExprParser.WhileStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 189
                self.match(MiniDecafExprParser.While)
                self.state = 190
                self.match(MiniDecafExprParser.Lparen)
                self.state = 191
                self.expression()
                self.state = 192
                self.match(MiniDecafExprParser.Rparen)
                self.state = 193
                self.statement()
                pass

            elif la_ == 9:
                localctx = MiniDecafExprParser.DoWhileStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 195
                self.match(MiniDecafExprParser.Do)
                self.state = 196
                self.statement()
                self.state = 197
                self.match(MiniDecafExprParser.While)
                self.state = 198
                self.match(MiniDecafExprParser.Lparen)
                self.state = 199
                self.expression()
                self.state = 200
                self.match(MiniDecafExprParser.Rparen)
                self.state = 201
                self.match(MiniDecafExprParser.Semicolon)
                pass

            elif la_ == 10:
                localctx = MiniDecafExprParser.BreakStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 203
                self.match(MiniDecafExprParser.Break)
                self.state = 204
                self.match(MiniDecafExprParser.Semicolon)
                pass

            elif la_ == 11:
                localctx = MiniDecafExprParser.ContinueStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 11)
                self.state = 205
                self.match(MiniDecafExprParser.Continue)
                self.state = 206
                self.match(MiniDecafExprParser.Semicolon)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assign(self):
            return self.getTypedRuleContext(MiniDecafExprParser.AssignContext,0)


        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)




    def expression(self):

        localctx = MiniDecafExprParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 209
            self.assign()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_assign

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TAssignContext(AssignContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.AssignContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def conditional(self):
            return self.getTypedRuleContext(MiniDecafExprParser.ConditionalContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTAssign" ):
                listener.enterTAssign(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTAssign" ):
                listener.exitTAssign(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTAssign" ):
                return visitor.visitTAssign(self)
            else:
                return visitor.visitChildren(self)


    class CAssignContext(AssignContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.AssignContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def unary(self):
            return self.getTypedRuleContext(MiniDecafExprParser.UnaryContext,0)

        def assignOperator(self):
            return self.getTypedRuleContext(MiniDecafExprParser.AssignOperatorContext,0)

        def assign(self):
            return self.getTypedRuleContext(MiniDecafExprParser.AssignContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCAssign" ):
                listener.enterCAssign(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCAssign" ):
                listener.exitCAssign(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCAssign" ):
                return visitor.visitCAssign(self)
            else:
                return visitor.visitChildren(self)



    def assign(self):

        localctx = MiniDecafExprParser.AssignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_assign)
        try:
            self.state = 216
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                localctx = MiniDecafExprParser.TAssignContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 211
                self.conditional()
                pass

            elif la_ == 2:
                localctx = MiniDecafExprParser.CAssignContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 212
                self.unary()
                self.state = 213
                self.assignOperator()
                self.state = 214
                self.assign()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_conditional

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TConditionalContext(ConditionalContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.ConditionalContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def logical_or(self):
            return self.getTypedRuleContext(MiniDecafExprParser.Logical_orContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTConditional" ):
                listener.enterTConditional(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTConditional" ):
                listener.exitTConditional(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTConditional" ):
                return visitor.visitTConditional(self)
            else:
                return visitor.visitChildren(self)


    class CConditionalContext(ConditionalContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.ConditionalContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def logical_or(self):
            return self.getTypedRuleContext(MiniDecafExprParser.Logical_orContext,0)

        def expression(self):
            return self.getTypedRuleContext(MiniDecafExprParser.ExpressionContext,0)

        def conditional(self):
            return self.getTypedRuleContext(MiniDecafExprParser.ConditionalContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCConditional" ):
                listener.enterCConditional(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCConditional" ):
                listener.exitCConditional(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCConditional" ):
                return visitor.visitCConditional(self)
            else:
                return visitor.visitChildren(self)



    def conditional(self):

        localctx = MiniDecafExprParser.ConditionalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_conditional)
        try:
            self.state = 225
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                localctx = MiniDecafExprParser.TConditionalContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 218
                self.logical_or(0)
                pass

            elif la_ == 2:
                localctx = MiniDecafExprParser.CConditionalContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 219
                self.logical_or(0)
                self.state = 220
                self.match(MiniDecafExprParser.T__0)
                self.state = 221
                self.expression()
                self.state = 222
                self.match(MiniDecafExprParser.T__1)
                self.state = 223
                self.conditional()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Logical_orContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_logical_or

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class TLogical_orContext(Logical_orContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.Logical_orContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def logical_and(self):
            return self.getTypedRuleContext(MiniDecafExprParser.Logical_andContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTLogical_or" ):
                listener.enterTLogical_or(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTLogical_or" ):
                listener.exitTLogical_or(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTLogical_or" ):
                return visitor.visitTLogical_or(self)
            else:
                return visitor.visitChildren(self)


    class CLogical_orContext(Logical_orContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.Logical_orContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def logical_or(self):
            return self.getTypedRuleContext(MiniDecafExprParser.Logical_orContext,0)

        def Double_bar(self):
            return self.getToken(MiniDecafExprParser.Double_bar, 0)
        def logical_and(self):
            return self.getTypedRuleContext(MiniDecafExprParser.Logical_andContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCLogical_or" ):
                listener.enterCLogical_or(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCLogical_or" ):
                listener.exitCLogical_or(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCLogical_or" ):
                return visitor.visitCLogical_or(self)
            else:
                return visitor.visitChildren(self)



    def logical_or(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = MiniDecafExprParser.Logical_orContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 24
        self.enterRecursionRule(localctx, 24, self.RULE_logical_or, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = MiniDecafExprParser.TLogical_orContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 228
            self.logical_and(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 235
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,19,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = MiniDecafExprParser.CLogical_orContext(self, MiniDecafExprParser.Logical_orContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_logical_or)
                    self.state = 230
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 231
                    self.match(MiniDecafExprParser.Double_bar)
                    self.state = 232
                    self.logical_and(0) 
                self.state = 237
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,19,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Logical_andContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_logical_and

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class TLogical_andContext(Logical_andContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.Logical_andContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def bit_or(self):
            return self.getTypedRuleContext(MiniDecafExprParser.Bit_orContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTLogical_and" ):
                listener.enterTLogical_and(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTLogical_and" ):
                listener.exitTLogical_and(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTLogical_and" ):
                return visitor.visitTLogical_and(self)
            else:
                return visitor.visitChildren(self)


    class CLogical_andContext(Logical_andContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.Logical_andContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def logical_and(self):
            return self.getTypedRuleContext(MiniDecafExprParser.Logical_andContext,0)

        def Double_amp(self):
            return self.getToken(MiniDecafExprParser.Double_amp, 0)
        def bit_or(self):
            return self.getTypedRuleContext(MiniDecafExprParser.Bit_orContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCLogical_and" ):
                listener.enterCLogical_and(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCLogical_and" ):
                listener.exitCLogical_and(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCLogical_and" ):
                return visitor.visitCLogical_and(self)
            else:
                return visitor.visitChildren(self)



    def logical_and(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = MiniDecafExprParser.Logical_andContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 26
        self.enterRecursionRule(localctx, 26, self.RULE_logical_and, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = MiniDecafExprParser.TLogical_andContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 239
            self.bit_or(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 246
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,20,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = MiniDecafExprParser.CLogical_andContext(self, MiniDecafExprParser.Logical_andContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_logical_and)
                    self.state = 241
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 242
                    self.match(MiniDecafExprParser.Double_amp)
                    self.state = 243
                    self.bit_or(0) 
                self.state = 248
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,20,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Bit_orContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_bit_or

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class TBit_orContext(Bit_orContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.Bit_orContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def bit_xor(self):
            return self.getTypedRuleContext(MiniDecafExprParser.Bit_xorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTBit_or" ):
                listener.enterTBit_or(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTBit_or" ):
                listener.exitTBit_or(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTBit_or" ):
                return visitor.visitTBit_or(self)
            else:
                return visitor.visitChildren(self)


    class CBit_orContext(Bit_orContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.Bit_orContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def bit_or(self):
            return self.getTypedRuleContext(MiniDecafExprParser.Bit_orContext,0)

        def bit_xor(self):
            return self.getTypedRuleContext(MiniDecafExprParser.Bit_xorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCBit_or" ):
                listener.enterCBit_or(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCBit_or" ):
                listener.exitCBit_or(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCBit_or" ):
                return visitor.visitCBit_or(self)
            else:
                return visitor.visitChildren(self)



    def bit_or(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = MiniDecafExprParser.Bit_orContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 28
        self.enterRecursionRule(localctx, 28, self.RULE_bit_or, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = MiniDecafExprParser.TBit_orContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 250
            self.bit_xor(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 257
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,21,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = MiniDecafExprParser.CBit_orContext(self, MiniDecafExprParser.Bit_orContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_bit_or)
                    self.state = 252
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 253
                    self.match(MiniDecafExprParser.T__2)
                    self.state = 254
                    self.bit_xor(0) 
                self.state = 259
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,21,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Bit_xorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_bit_xor

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class TBit_xorContext(Bit_xorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.Bit_xorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def bit_and(self):
            return self.getTypedRuleContext(MiniDecafExprParser.Bit_andContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTBit_xor" ):
                listener.enterTBit_xor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTBit_xor" ):
                listener.exitTBit_xor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTBit_xor" ):
                return visitor.visitTBit_xor(self)
            else:
                return visitor.visitChildren(self)


    class CBit_xorContext(Bit_xorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.Bit_xorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def bit_xor(self):
            return self.getTypedRuleContext(MiniDecafExprParser.Bit_xorContext,0)

        def bit_and(self):
            return self.getTypedRuleContext(MiniDecafExprParser.Bit_andContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCBit_xor" ):
                listener.enterCBit_xor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCBit_xor" ):
                listener.exitCBit_xor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCBit_xor" ):
                return visitor.visitCBit_xor(self)
            else:
                return visitor.visitChildren(self)



    def bit_xor(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = MiniDecafExprParser.Bit_xorContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 30
        self.enterRecursionRule(localctx, 30, self.RULE_bit_xor, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = MiniDecafExprParser.TBit_xorContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 261
            self.bit_and(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 268
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,22,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = MiniDecafExprParser.CBit_xorContext(self, MiniDecafExprParser.Bit_xorContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_bit_xor)
                    self.state = 263
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 264
                    self.match(MiniDecafExprParser.T__3)
                    self.state = 265
                    self.bit_and(0) 
                self.state = 270
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,22,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Bit_andContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_bit_and

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class CBit_andContext(Bit_andContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.Bit_andContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def bit_and(self):
            return self.getTypedRuleContext(MiniDecafExprParser.Bit_andContext,0)

        def Ampersand(self):
            return self.getToken(MiniDecafExprParser.Ampersand, 0)
        def equal(self):
            return self.getTypedRuleContext(MiniDecafExprParser.EqualContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCBit_and" ):
                listener.enterCBit_and(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCBit_and" ):
                listener.exitCBit_and(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCBit_and" ):
                return visitor.visitCBit_and(self)
            else:
                return visitor.visitChildren(self)


    class TBit_andContext(Bit_andContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.Bit_andContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def equal(self):
            return self.getTypedRuleContext(MiniDecafExprParser.EqualContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTBit_and" ):
                listener.enterTBit_and(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTBit_and" ):
                listener.exitTBit_and(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTBit_and" ):
                return visitor.visitTBit_and(self)
            else:
                return visitor.visitChildren(self)



    def bit_and(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = MiniDecafExprParser.Bit_andContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 32
        self.enterRecursionRule(localctx, 32, self.RULE_bit_and, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = MiniDecafExprParser.TBit_andContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 272
            self.equal(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 279
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,23,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = MiniDecafExprParser.CBit_andContext(self, MiniDecafExprParser.Bit_andContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_bit_and)
                    self.state = 274
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 275
                    self.match(MiniDecafExprParser.Ampersand)
                    self.state = 276
                    self.equal(0) 
                self.state = 281
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,23,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class EqualContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_equal

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class CEqualContext(EqualContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.EqualContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def equal(self):
            return self.getTypedRuleContext(MiniDecafExprParser.EqualContext,0)

        def equalOperator(self):
            return self.getTypedRuleContext(MiniDecafExprParser.EqualOperatorContext,0)

        def relational(self):
            return self.getTypedRuleContext(MiniDecafExprParser.RelationalContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCEqual" ):
                listener.enterCEqual(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCEqual" ):
                listener.exitCEqual(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCEqual" ):
                return visitor.visitCEqual(self)
            else:
                return visitor.visitChildren(self)


    class TEqualContext(EqualContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.EqualContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def relational(self):
            return self.getTypedRuleContext(MiniDecafExprParser.RelationalContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTEqual" ):
                listener.enterTEqual(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTEqual" ):
                listener.exitTEqual(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTEqual" ):
                return visitor.visitTEqual(self)
            else:
                return visitor.visitChildren(self)



    def equal(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = MiniDecafExprParser.EqualContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 34
        self.enterRecursionRule(localctx, 34, self.RULE_equal, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = MiniDecafExprParser.TEqualContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 283
            self.relational(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 291
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,24,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = MiniDecafExprParser.CEqualContext(self, MiniDecafExprParser.EqualContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_equal)
                    self.state = 285
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 286
                    self.equalOperator()
                    self.state = 287
                    self.relational(0) 
                self.state = 293
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,24,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class RelationalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_relational

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class CRelationalContext(RelationalContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.RelationalContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def relational(self):
            return self.getTypedRuleContext(MiniDecafExprParser.RelationalContext,0)

        def relationalOperator(self):
            return self.getTypedRuleContext(MiniDecafExprParser.RelationalOperatorContext,0)

        def add(self):
            return self.getTypedRuleContext(MiniDecafExprParser.AddContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCRelational" ):
                listener.enterCRelational(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCRelational" ):
                listener.exitCRelational(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCRelational" ):
                return visitor.visitCRelational(self)
            else:
                return visitor.visitChildren(self)


    class TRelationalContext(RelationalContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.RelationalContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def add(self):
            return self.getTypedRuleContext(MiniDecafExprParser.AddContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTRelational" ):
                listener.enterTRelational(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTRelational" ):
                listener.exitTRelational(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTRelational" ):
                return visitor.visitTRelational(self)
            else:
                return visitor.visitChildren(self)



    def relational(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = MiniDecafExprParser.RelationalContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 36
        self.enterRecursionRule(localctx, 36, self.RULE_relational, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = MiniDecafExprParser.TRelationalContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 295
            self.add(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 303
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,25,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = MiniDecafExprParser.CRelationalContext(self, MiniDecafExprParser.RelationalContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_relational)
                    self.state = 297
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 298
                    self.relationalOperator()
                    self.state = 299
                    self.add(0) 
                self.state = 305
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,25,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class AddContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_add

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class CAddContext(AddContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.AddContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def add(self):
            return self.getTypedRuleContext(MiniDecafExprParser.AddContext,0)

        def addOperator(self):
            return self.getTypedRuleContext(MiniDecafExprParser.AddOperatorContext,0)

        def multiply(self):
            return self.getTypedRuleContext(MiniDecafExprParser.MultiplyContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCAdd" ):
                listener.enterCAdd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCAdd" ):
                listener.exitCAdd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCAdd" ):
                return visitor.visitCAdd(self)
            else:
                return visitor.visitChildren(self)


    class TAddContext(AddContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.AddContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def multiply(self):
            return self.getTypedRuleContext(MiniDecafExprParser.MultiplyContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTAdd" ):
                listener.enterTAdd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTAdd" ):
                listener.exitTAdd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTAdd" ):
                return visitor.visitTAdd(self)
            else:
                return visitor.visitChildren(self)



    def add(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = MiniDecafExprParser.AddContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 38
        self.enterRecursionRule(localctx, 38, self.RULE_add, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = MiniDecafExprParser.TAddContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 307
            self.multiply(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 315
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,26,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = MiniDecafExprParser.CAddContext(self, MiniDecafExprParser.AddContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_add)
                    self.state = 309
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 310
                    self.addOperator()
                    self.state = 311
                    self.multiply(0) 
                self.state = 317
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,26,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class MultiplyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_multiply

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class TMultiplyContext(MultiplyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.MultiplyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def cast(self):
            return self.getTypedRuleContext(MiniDecafExprParser.CastContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTMultiply" ):
                listener.enterTMultiply(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTMultiply" ):
                listener.exitTMultiply(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTMultiply" ):
                return visitor.visitTMultiply(self)
            else:
                return visitor.visitChildren(self)


    class CMultiplyContext(MultiplyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.MultiplyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def multiply(self):
            return self.getTypedRuleContext(MiniDecafExprParser.MultiplyContext,0)

        def multiplyOperator(self):
            return self.getTypedRuleContext(MiniDecafExprParser.MultiplyOperatorContext,0)

        def cast(self):
            return self.getTypedRuleContext(MiniDecafExprParser.CastContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCMultiply" ):
                listener.enterCMultiply(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCMultiply" ):
                listener.exitCMultiply(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCMultiply" ):
                return visitor.visitCMultiply(self)
            else:
                return visitor.visitChildren(self)



    def multiply(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = MiniDecafExprParser.MultiplyContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 40
        self.enterRecursionRule(localctx, 40, self.RULE_multiply, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = MiniDecafExprParser.TMultiplyContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 319
            self.cast()
            self._ctx.stop = self._input.LT(-1)
            self.state = 327
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,27,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = MiniDecafExprParser.CMultiplyContext(self, MiniDecafExprParser.MultiplyContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_multiply)
                    self.state = 321
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 322
                    self.multiplyOperator()
                    self.state = 323
                    self.cast() 
                self.state = 329
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,27,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class CastContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_cast

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TCastContext(CastContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.CastContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def unary(self):
            return self.getTypedRuleContext(MiniDecafExprParser.UnaryContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTCast" ):
                listener.enterTCast(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTCast" ):
                listener.exitTCast(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTCast" ):
                return visitor.visitTCast(self)
            else:
                return visitor.visitChildren(self)


    class CCastContext(CastContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.CastContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Lparen(self):
            return self.getToken(MiniDecafExprParser.Lparen, 0)
        def variableType(self):
            return self.getTypedRuleContext(MiniDecafExprParser.VariableTypeContext,0)

        def Rparen(self):
            return self.getToken(MiniDecafExprParser.Rparen, 0)
        def cast(self):
            return self.getTypedRuleContext(MiniDecafExprParser.CastContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCCast" ):
                listener.enterCCast(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCCast" ):
                listener.exitCCast(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCCast" ):
                return visitor.visitCCast(self)
            else:
                return visitor.visitChildren(self)



    def cast(self):

        localctx = MiniDecafExprParser.CastContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_cast)
        try:
            self.state = 336
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
            if la_ == 1:
                localctx = MiniDecafExprParser.TCastContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 330
                self.unary()
                pass

            elif la_ == 2:
                localctx = MiniDecafExprParser.CCastContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 331
                self.match(MiniDecafExprParser.Lparen)
                self.state = 332
                self.variableType(0)
                self.state = 333
                self.match(MiniDecafExprParser.Rparen)
                self.state = 334
                self.cast()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_unary

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TUnaryContext(UnaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.UnaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def postfix(self):
            return self.getTypedRuleContext(MiniDecafExprParser.PostfixContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTUnary" ):
                listener.enterTUnary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTUnary" ):
                listener.exitTUnary(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTUnary" ):
                return visitor.visitTUnary(self)
            else:
                return visitor.visitChildren(self)


    class CUnaryContext(UnaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.UnaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def unaryOperator(self):
            return self.getTypedRuleContext(MiniDecafExprParser.UnaryOperatorContext,0)

        def cast(self):
            return self.getTypedRuleContext(MiniDecafExprParser.CastContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCUnary" ):
                listener.enterCUnary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCUnary" ):
                listener.exitCUnary(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCUnary" ):
                return visitor.visitCUnary(self)
            else:
                return visitor.visitChildren(self)



    def unary(self):

        localctx = MiniDecafExprParser.UnaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_unary)
        try:
            self.state = 342
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [MiniDecafExprParser.Lparen, MiniDecafExprParser.Integer, MiniDecafExprParser.Identifier]:
                localctx = MiniDecafExprParser.TUnaryContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 338
                self.postfix(0)
                pass
            elif token in [MiniDecafExprParser.Sub, MiniDecafExprParser.Mul, MiniDecafExprParser.Exclamation, MiniDecafExprParser.Tilde, MiniDecafExprParser.Ampersand]:
                localctx = MiniDecafExprParser.CUnaryContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 339
                self.unaryOperator()
                self.state = 340
                self.cast()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PostfixContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_postfix

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class PostfixArrayContext(PostfixContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.PostfixContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def postfix(self):
            return self.getTypedRuleContext(MiniDecafExprParser.PostfixContext,0)

        def Lbrkt(self):
            return self.getToken(MiniDecafExprParser.Lbrkt, 0)
        def expression(self):
            return self.getTypedRuleContext(MiniDecafExprParser.ExpressionContext,0)

        def Rbrkt(self):
            return self.getToken(MiniDecafExprParser.Rbrkt, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPostfixArray" ):
                listener.enterPostfixArray(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPostfixArray" ):
                listener.exitPostfixArray(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPostfixArray" ):
                return visitor.visitPostfixArray(self)
            else:
                return visitor.visitChildren(self)


    class PostfixCallContext(PostfixContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.PostfixContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Identifier(self):
            return self.getToken(MiniDecafExprParser.Identifier, 0)
        def Lparen(self):
            return self.getToken(MiniDecafExprParser.Lparen, 0)
        def argumentList(self):
            return self.getTypedRuleContext(MiniDecafExprParser.ArgumentListContext,0)

        def Rparen(self):
            return self.getToken(MiniDecafExprParser.Rparen, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPostfixCall" ):
                listener.enterPostfixCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPostfixCall" ):
                listener.exitPostfixCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPostfixCall" ):
                return visitor.visitPostfixCall(self)
            else:
                return visitor.visitChildren(self)


    class TPostfixContext(PostfixContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.PostfixContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def atom(self):
            return self.getTypedRuleContext(MiniDecafExprParser.AtomContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTPostfix" ):
                listener.enterTPostfix(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTPostfix" ):
                listener.exitTPostfix(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTPostfix" ):
                return visitor.visitTPostfix(self)
            else:
                return visitor.visitChildren(self)



    def postfix(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = MiniDecafExprParser.PostfixContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 46
        self.enterRecursionRule(localctx, 46, self.RULE_postfix, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 351
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
            if la_ == 1:
                localctx = MiniDecafExprParser.TPostfixContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 345
                self.atom()
                pass

            elif la_ == 2:
                localctx = MiniDecafExprParser.PostfixCallContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 346
                self.match(MiniDecafExprParser.Identifier)
                self.state = 347
                self.match(MiniDecafExprParser.Lparen)
                self.state = 348
                self.argumentList()
                self.state = 349
                self.match(MiniDecafExprParser.Rparen)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 360
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,31,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = MiniDecafExprParser.PostfixArrayContext(self, MiniDecafExprParser.PostfixContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_postfix)
                    self.state = 353
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 354
                    self.match(MiniDecafExprParser.Lbrkt)
                    self.state = 355
                    self.expression()
                    self.state = 356
                    self.match(MiniDecafExprParser.Rbrkt) 
                self.state = 362
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,31,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ArgumentListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MiniDecafExprParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(MiniDecafExprParser.ExpressionContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(MiniDecafExprParser.Comma)
            else:
                return self.getToken(MiniDecafExprParser.Comma, i)

        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_argumentList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgumentList" ):
                listener.enterArgumentList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgumentList" ):
                listener.exitArgumentList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArgumentList" ):
                return visitor.visitArgumentList(self)
            else:
                return visitor.visitChildren(self)




    def argumentList(self):

        localctx = MiniDecafExprParser.ArgumentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_argumentList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 371
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << MiniDecafExprParser.Lparen) | (1 << MiniDecafExprParser.Sub) | (1 << MiniDecafExprParser.Mul) | (1 << MiniDecafExprParser.Exclamation) | (1 << MiniDecafExprParser.Tilde) | (1 << MiniDecafExprParser.Ampersand) | (1 << MiniDecafExprParser.Integer) | (1 << MiniDecafExprParser.Identifier))) != 0):
                self.state = 363
                self.expression()
                self.state = 368
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==MiniDecafExprParser.Comma:
                    self.state = 364
                    self.match(MiniDecafExprParser.Comma)
                    self.state = 365
                    self.expression()
                    self.state = 370
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AtomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_atom

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class AtomIdentifierContext(AtomContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.AtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Identifier(self):
            return self.getToken(MiniDecafExprParser.Identifier, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtomIdentifier" ):
                listener.enterAtomIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtomIdentifier" ):
                listener.exitAtomIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomIdentifier" ):
                return visitor.visitAtomIdentifier(self)
            else:
                return visitor.visitChildren(self)


    class AtomIntegerContext(AtomContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.AtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Integer(self):
            return self.getToken(MiniDecafExprParser.Integer, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtomInteger" ):
                listener.enterAtomInteger(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtomInteger" ):
                listener.exitAtomInteger(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomInteger" ):
                return visitor.visitAtomInteger(self)
            else:
                return visitor.visitChildren(self)


    class AtomParenContext(AtomContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MiniDecafExprParser.AtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Lparen(self):
            return self.getToken(MiniDecafExprParser.Lparen, 0)
        def expression(self):
            return self.getTypedRuleContext(MiniDecafExprParser.ExpressionContext,0)

        def Rparen(self):
            return self.getToken(MiniDecafExprParser.Rparen, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtomParen" ):
                listener.enterAtomParen(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtomParen" ):
                listener.exitAtomParen(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomParen" ):
                return visitor.visitAtomParen(self)
            else:
                return visitor.visitChildren(self)



    def atom(self):

        localctx = MiniDecafExprParser.AtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_atom)
        try:
            self.state = 379
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [MiniDecafExprParser.Integer]:
                localctx = MiniDecafExprParser.AtomIntegerContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 373
                self.match(MiniDecafExprParser.Integer)
                pass
            elif token in [MiniDecafExprParser.Identifier]:
                localctx = MiniDecafExprParser.AtomIdentifierContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 374
                self.match(MiniDecafExprParser.Identifier)
                pass
            elif token in [MiniDecafExprParser.Lparen]:
                localctx = MiniDecafExprParser.AtomParenContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 375
                self.match(MiniDecafExprParser.Lparen)
                self.state = 376
                self.expression()
                self.state = 377
                self.match(MiniDecafExprParser.Rparen)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AddOperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Add(self):
            return self.getToken(MiniDecafExprParser.Add, 0)

        def Sub(self):
            return self.getToken(MiniDecafExprParser.Sub, 0)

        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_addOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddOperator" ):
                listener.enterAddOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddOperator" ):
                listener.exitAddOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAddOperator" ):
                return visitor.visitAddOperator(self)
            else:
                return visitor.visitChildren(self)




    def addOperator(self):

        localctx = MiniDecafExprParser.AddOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_addOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 381
            _la = self._input.LA(1)
            if not(_la==MiniDecafExprParser.Add or _la==MiniDecafExprParser.Sub):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiplyOperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Mul(self):
            return self.getToken(MiniDecafExprParser.Mul, 0)

        def Div(self):
            return self.getToken(MiniDecafExprParser.Div, 0)

        def Percent(self):
            return self.getToken(MiniDecafExprParser.Percent, 0)

        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_multiplyOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplyOperator" ):
                listener.enterMultiplyOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplyOperator" ):
                listener.exitMultiplyOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplyOperator" ):
                return visitor.visitMultiplyOperator(self)
            else:
                return visitor.visitChildren(self)




    def multiplyOperator(self):

        localctx = MiniDecafExprParser.MultiplyOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_multiplyOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 383
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << MiniDecafExprParser.Mul) | (1 << MiniDecafExprParser.Div) | (1 << MiniDecafExprParser.Percent))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EqualOperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Double_eq(self):
            return self.getToken(MiniDecafExprParser.Double_eq, 0)

        def Exclam_eq(self):
            return self.getToken(MiniDecafExprParser.Exclam_eq, 0)

        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_equalOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEqualOperator" ):
                listener.enterEqualOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEqualOperator" ):
                listener.exitEqualOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEqualOperator" ):
                return visitor.visitEqualOperator(self)
            else:
                return visitor.visitChildren(self)




    def equalOperator(self):

        localctx = MiniDecafExprParser.EqualOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_equalOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 385
            _la = self._input.LA(1)
            if not(_la==MiniDecafExprParser.Double_eq or _la==MiniDecafExprParser.Exclam_eq):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryOperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Sub(self):
            return self.getToken(MiniDecafExprParser.Sub, 0)

        def Exclamation(self):
            return self.getToken(MiniDecafExprParser.Exclamation, 0)

        def Tilde(self):
            return self.getToken(MiniDecafExprParser.Tilde, 0)

        def Mul(self):
            return self.getToken(MiniDecafExprParser.Mul, 0)

        def Ampersand(self):
            return self.getToken(MiniDecafExprParser.Ampersand, 0)

        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_unaryOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryOperator" ):
                listener.enterUnaryOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryOperator" ):
                listener.exitUnaryOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryOperator" ):
                return visitor.visitUnaryOperator(self)
            else:
                return visitor.visitChildren(self)




    def unaryOperator(self):

        localctx = MiniDecafExprParser.UnaryOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_unaryOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 387
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << MiniDecafExprParser.Sub) | (1 << MiniDecafExprParser.Mul) | (1 << MiniDecafExprParser.Exclamation) | (1 << MiniDecafExprParser.Tilde) | (1 << MiniDecafExprParser.Ampersand))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationalOperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Langle(self):
            return self.getToken(MiniDecafExprParser.Langle, 0)

        def Rangle(self):
            return self.getToken(MiniDecafExprParser.Rangle, 0)

        def Langle_eq(self):
            return self.getToken(MiniDecafExprParser.Langle_eq, 0)

        def Rangle_eq(self):
            return self.getToken(MiniDecafExprParser.Rangle_eq, 0)

        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_relationalOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationalOperator" ):
                listener.enterRelationalOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationalOperator" ):
                listener.exitRelationalOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelationalOperator" ):
                return visitor.visitRelationalOperator(self)
            else:
                return visitor.visitChildren(self)




    def relationalOperator(self):

        localctx = MiniDecafExprParser.RelationalOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_relationalOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 389
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << MiniDecafExprParser.Langle) | (1 << MiniDecafExprParser.Rangle) | (1 << MiniDecafExprParser.Langle_eq) | (1 << MiniDecafExprParser.Rangle_eq))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignOperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Equal(self):
            return self.getToken(MiniDecafExprParser.Equal, 0)

        def getRuleIndex(self):
            return MiniDecafExprParser.RULE_assignOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignOperator" ):
                listener.enterAssignOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignOperator" ):
                listener.exitAssignOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignOperator" ):
                return visitor.visitAssignOperator(self)
            else:
                return visitor.visitChildren(self)




    def assignOperator(self):

        localctx = MiniDecafExprParser.AssignOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_assignOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 391
            self.match(MiniDecafExprParser.Equal)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[3] = self.variableType_sempred
        self._predicates[12] = self.logical_or_sempred
        self._predicates[13] = self.logical_and_sempred
        self._predicates[14] = self.bit_or_sempred
        self._predicates[15] = self.bit_xor_sempred
        self._predicates[16] = self.bit_and_sempred
        self._predicates[17] = self.equal_sempred
        self._predicates[18] = self.relational_sempred
        self._predicates[19] = self.add_sempred
        self._predicates[20] = self.multiply_sempred
        self._predicates[23] = self.postfix_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def variableType_sempred(self, localctx:VariableTypeContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 1)
         

    def logical_or_sempred(self, localctx:Logical_orContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 1)
         

    def logical_and_sempred(self, localctx:Logical_andContext, predIndex:int):
            if predIndex == 2:
                return self.precpred(self._ctx, 1)
         

    def bit_or_sempred(self, localctx:Bit_orContext, predIndex:int):
            if predIndex == 3:
                return self.precpred(self._ctx, 1)
         

    def bit_xor_sempred(self, localctx:Bit_xorContext, predIndex:int):
            if predIndex == 4:
                return self.precpred(self._ctx, 1)
         

    def bit_and_sempred(self, localctx:Bit_andContext, predIndex:int):
            if predIndex == 5:
                return self.precpred(self._ctx, 1)
         

    def equal_sempred(self, localctx:EqualContext, predIndex:int):
            if predIndex == 6:
                return self.precpred(self._ctx, 1)
         

    def relational_sempred(self, localctx:RelationalContext, predIndex:int):
            if predIndex == 7:
                return self.precpred(self._ctx, 1)
         

    def add_sempred(self, localctx:AddContext, predIndex:int):
            if predIndex == 8:
                return self.precpred(self._ctx, 1)
         

    def multiply_sempred(self, localctx:MultiplyContext, predIndex:int):
            if predIndex == 9:
                return self.precpred(self._ctx, 1)
         

    def postfix_sempred(self, localctx:PostfixContext, predIndex:int):
            if predIndex == 10:
                return self.precpred(self._ctx, 2)
         




