### Step11实验报告

2018013443 陈新 计82

#### 实验内容

1. 引入左值，这一步只需要将`assign`部分的`Identifier`改成`unary`（并修改IR生成时`visit`语法树的代码。我从实验一开始就实现了该部分，因此无需改动
2. 增加类型检查，为此在名称解析与IR生生成之间增添了一遍pass，用于检查类型。需要对每个`expression`记录类型（目前只有`int/void`）与大小（step12需要，因此在这个阶段一起加上），并在计算、比较、返回值等地方比较变量类型是否一致，两个表达式是否能做特定运算
3. 增加指针、&（取址）*（解引用）操作、类型转换，因此在类型检查的pass中指针类型变量还需要记录其基类型，利用`context->type`的字典存储所有`expression`的类型并验证

---------------------

#### 思考题

1. 为什么类型检查要放到名称解析之后？

   因为只有先做好名称解析，才能确保不出现`undefined/redefined`等bug，才能保证类型记录的时候不会遇到未定义变量等

   也只有在先生成变量、函数信息的情况下，才能在变量、函数信息中相应地记录下类型并作比较、检查

   

2. MiniDecaf 中一个值只能有一种类型，但在很多语言中并非如此，请举出一个反例。

   C++的0可以是bool类型的false，可以是指针类型的nullptr，可以是int类型的0

   

3. 在本次实验中我们禁止进行指针的比大小运算。请问如果要实现指针大小比较需要注意什么问题？可以和原来整数比较的方法一样吗？

   不能和整数比较的方法一样。因为指针没有负值，是无符号整数。原先的整数比较是利用`slt/sgt`指令，这是针对有符号整数的比较。

   所以无符号数（指针）比较大小需要先取出其最高位比较，如果相等再将最高位置零后当作有符号整数的正数用`slt/sgt`指令比较

   
