### Step12实验报告

2018013443 陈新 计82

#### 实验内容

现在对数组的实现是完全静态定义大小的，因此可以静态确定下标、数组内存空间大小等

在`typer`的pass生成对数组变量的变量信息，由于`Antlr4`的识别语法写的是

```
postfix
	: atom								# tPostfix
	| postfix '[' expression ']'		# postfixArray
	| Identifier '(' argumentList ')'	# postfixCall
	;
```

因此生成的语法树会按从右向左的优先顺序访问`[]`。将右侧已经生成的`ArrayType`作为基类迭代生成`ArrayType`，就会形成套娃式`ArrayType`，且数组每一维的地址符合对数组地址的规则定义

在IR生成的时候如果要访问`ArrayType`只需要先将数组的头地址压栈，然后每遇到一维下标就寻找该下标对应的`ArrayType`的`size`，`+size*num`即可



所以这样的数组定义/访问方式无法实现变长数组，但对于确定长度的数组可以加快访问速度

---------------------

#### 思考题

1. 分别给出每个函数的返回值，用一个常量 minidecaf 表达式表示

   ```C++
   A() = *(int*)(4096 + 23 * 4);
   B() = *(int*)(4096 + 23 * 4);
   C() = *(int*)(4096 + (2 * 10 + 3) * 4);
   D() = *((*(int**)(4096 + 2 * 4)) + 3 * 4);
   E() = *((*(int**)(4096 + 2 * 4)) + 3 * 4);
   ```

   

2. C 语言规范规定，允许局部变量是可变长度的数组（[Variable Length Array](https://en.wikipedia.org/wiki/Variable-length_array)，VLA），在我们的实验中为了简化，选择不支持它。请你简要回答，如果我们决定支持一维的可变长度的数组(即允许类似`int n = 5; int a[n];` 这种，但仍然不允许类似 `int n = ...; int m = ...; int a[n][m];` 这种)，而且要求数组仍然保存在栈上（即不允许用堆上的动态内存申请，如`malloc`等来实现它），应该在现有的实现基础上做出那些改动？

   

   **方法1**：现有实现方式不做大改变，特判一维变长数组合法。如果遇到`int n = 5; int a[n];`这种情况，则将定义数组时n的值和数组首位地址存储到栈上记录，并依次分配栈空间。将具体的数组数据段放置到栈帧的局部变量段的最后，同时存在多个变长数组的时候，后面的数组首位地址用前面数组的首位地址和长度累加计算

   **方法2**：将现有的“IR生成前确定数组各维大小”改为“在栈上存储数组维数、各维的size“，定义数组变量时栈空间分配先load这些参数乘起来作为整个数组的size；访问数组时load每一维的长度计算地址。然后特判多维变长数组非法。该方法会极大增加访问数组的地址计算开销，但可扩展性强，虽然题目要求多维变长数组非法，但是如果要实现，只需要将特判非法的部分删去即可
